/*!

  \mainpage Теоретическое введение

 TMS-сети - это способ поиска лучших параметров математической модели.Этим вопросом занимались три человека. Сначала Соболь,со своими \f$ ЛП_0 \f$,\f$ ЛП_t \f$-последовательностями,затем Фор,который смог обобщить часть из них.Также Нидеррайтер занимался этим вопросом. В результате своих исследований он ввел (t,s)-последовательности.
     

            Часть 1.Последовательности Соболя
  Определение \f$П_0\f$-сеток и \f$ЛП_0 \f$- последовательностей


Сетку, состоящую из \f$ 2^\gamma \f$ точек, где \gamma – целое, назовем \f$ П_0 \f$-сеткой, если каждому двоичному отрезку с длиной 1/m принадлежит одна точка сетки.
\f$ П_0 \f$-сетки представляют собой очень хорошие сетки по равномерности расположения точек.

Двоичным участком последовательности \f$ x_0 \f$, \f$ x_1 \f$,…,\f$ x_i \f$,… называется множество членов \f$ x_i \f$ с номерами i удовлетворяющими неравенству: \f$ k2^b \le i < (k+1)2^b\f$. Последовательность {\f$ x_i \f$ } назовем \f$ ЛП_0 \f$- последовательностью, если любой её двоичный участок представляет собой \f$ П_0 \f$-сетку. Само название расшифровывается как “Любой двоичный участок есть \f$ П_0 \f$-сетка”.
Оценка для равномерности  имеет вид: \f$ \phi_{\infty}(x_0,x_1,…,x_{m-1})=1\f$, \f$ D(x_0,x_1,…,x_{m-1}) \le L\f$.


     Количественные характеристики равномерности

1) Отклонение(discrepancy).
Фиксируем точки \f$ x_0 \f$, \f$ x_1 \f$,…,\f$ x_{m-1}\f$, принадлежащие отрезку \f$[0,1]\f$, которые для краткости будем называть сеткой. Обозначим через \f$ S_m(x)\f$ кол-во точек сетки, принадлежащих отрезку \f$[0,x)\f$. Иначе говоря, \f$ S_m(x)=S_m(l), l=[0,x)\f$. Отклонением сетки \f$ x_0,x_1,…,x_{m-1}\f$ называется:
\f[ D(x_0,…,x_{m-1})=\sup_{0 \le x \le 1} | S_m(x)-mx|\f]
                                
Проведя ряд преобразований согласно книге Соболя мы можем используя данную формулу получить следующую (формула Нидеррайтера,1972):  \f[ D= 1/2 + \max_{1 \le i \le m}|i- 1/2 -mx_i| \f] 

2) Неравномерность 
Как и в случае с отклонением мы рассматриваем сетку \f$ x_0 \f$, \f$ x_1 \f$,…,\f$ x_{m-1}\f$, принадлежащие отрезку \f$ [0,1]\f$. Выбираем произвольный двоичный отрезок \f$l_k\f$. Приидеально равномерном расположении  точек сетки в левую и правую половины \f$l_k\f$ должно попасть одинаковое количество этих точек. Поэтому величина \f$ |S_m(l^-)–S_m(l^+)| \f$ в какой-то мере характерезует неравномерность расположения точек сетки в \f$l_k\f$.
Неравномерностью сетки \f$ x_0,x_1,…,x_{m-1}\f$ называется целое число 
 \f[ \phi(x_0,x_1,…,x_{m-1})=\sup_{k}| S_m(l_k^-) –S_m(l_k^+) |\f]       
                                                                                                                                                                                                                       
Верхняя грань берется по всем двоичным отрезкам.

3)Разброс(dispersion of points)
Разбросом точек \f$ x_0,x_1,…,x_{m-1}\f$ называется величина .
В работах Соболя приводились доказательства того, что величина неравномерности любой \f$П_0\f$-секти равно 1, а величина отклонения меньше или равна единице. Также все \f$ЛП_0\f$-последовательности имеют порядок роста \f$D=O(\ln m)\f$.



  Определение \f$ П_t \f$ -сеток и \f$ ЛП_t \f$- последовательностей

Последовательность точек \f$P_0,…,P_1,…,P_i,…\f$ куба \f$К^s\f$ назовем \f$ЛП_\tau\f$-последовательностью, если каждый её двоичный участок содержащий не менее \f$2t+1\f$ точек, представляет из себя \f$П_t\f$-сетку.

Сетка состоящая из \f$2^\gamma\f$ точек куба \f$К^s\f$, называется \f$П_\tau\f$-сеткой, если каждому двоичному параллелепипеду \f$П_к\f$ с объемом  \f$|П_к|=2^{\gamma-t}\f$ принадлежит \f$2^t\f$ точек сетки. При этом всегда предполагается, что \f$\gamma>t\f$. И если некоторая \f$ П_t \f$-сетка не является \f$П_{t-1}\f$-сеткой, то тогда значение \f$ t \f$ для неё точное.
Проекция \f$ ЛП_t \f$-последовательности на какую-либо координатную грань \f$ К_{t_1,…,t_c} \f$  куба \f$К^s\f$ образует c-мерную \f$ ЛП_t \f$-последовательность.
Далее имеет место быть важная теорема:  для любого произвольного участка  \f$ ЛП_t \f$-последовательности в \f$К^s\f$ справедлива следующая оценка \f[ \phi_{infty} = 2^{m-1+t} \f]
Это оценка неравномерности \f$ П_t \f$-сетки. 
Как следствие из доказательства этой теоремы мы получаем, что участка  \f$ ЛП_t \f$-последовательность равномерна распределена в \f$К^s\f$.

       Линейные разностные операторы в поле Z_2

Рассмотрим линейное разностное уравнение m-ого порядка с постоянными коэффициентами.
\f$ (*)Lu_i=0\f$ , где разностный оператор L определен выражением:
\f$ (**)Lu_i=u_{i+p}+a_{p-1}u_{i+p-1}+…+a_1u_{i+1}+u_i \f$ , все \f$ u_i \f$ и \f$ a_j\f$  принадлежат \f$ Z_2\f$ 

Возьмем нетривиальное решение нашего уравнения и рассмотрим группы значений \f$ (u_1,…,u_p)\f$ ,\f$ (u_2,…,u_{p+1})\f$ ,….Всего \f$ 2^p -1\f$  нетривиальных групп содержащих нули и единицы, значит найдется такая группа \f$ (u_{w+1},…,u_{w+m})\f$ , совпадающая с \f$ (u_1,…,u_p)\f$ . В силу нашего уравнения все значения \f$ u_{w+I} = u_i\f$ . Таким образом получается,что наше решение является периодическим с минимальным периодом \f$ w_1 \le 2^p -1\f$ .
Уравнение \f$(*) \f$ и оператор \f$(**)\f$ называют моноциклическими, если уравнение \f$(*)\f$ имеет решение с наименьшим периодом \f$w=2^p -1\f$.


    Построение ЛП_{\tau} последовательностей

1)Построение \f$ДР\f$-последовательностей
Рассмотрим произвольный моноциклический оператор в поле \f$Z_2\f$, порядок которого равен \f$m\f$. Определим направляющие числа \f$V_1,…V_i,…\f$  из уравнения \f[ V_{i+p}*a_{p-1}V_{i+p-1}*…*a_1V_{i+1}*V_i=2^{p-1}V_i  (*)\f]
Иными словами: \f$ LV_i=2^{p-1}V_i \f$ 
Наложим условия на начальные значения \f$V_i\f$. Если в двоичной системе \f$ V_i=0, v_{i1},v_{i2}...v_{ij}\f$, 
\f[
B = \begin{pmatrix}
v_{11} & ... & v_{1p} \\
... & ... & ... \\         
v_{p1} & ... & v_{pp}
\end{pmatrix} \f]
то все \f$v_{ii}=1\f$ , а при \f$j>I\f$ \f$v_{ij}=0\f$.  
Др-последовательность \f${r(i)}\f$ с такими направляющими числами \f${V(i)}\f$ принадлежит оператору \f$L\f$.
Уравнение \f$(*)\f$ эквивалентно системе уравнений в поле \f$Z^2\f$,определяющих значение \f$v_{ij}\f$ в каждом из двоичных разрядов:
\f[ Lv_{ij}=0, если 1 \le j \le p
    Lv_{ij}=v_{i,j-p}, если p<j<\infty \f]
Рассмотрим двунаправленную матрицу ДР-последовательности, принадлежащей оператору \f$L\f$. С учетом выбора \f$V_i\f$ матрицу можно представить в таком виде:
\f[
\begin{pmatrix}
1 & 0 & ...0 & | & 0 & ... \\
v_{21} & 1 & ...0 & | & 0 & ... \\
v_{31} & v_{32} & ...0 & | & 0 & ... \\
... & ... & ... & | & ... & ...\\
v_{21} & 1 & ...0 & | & 0 & ... \\         
v_{p1} & v_{p1} & ...1 & | & 0 & ... \\
\hline \\
v_{p+1,1} & v_{p+1,2} & ... & | & v_{p+1,p+1} & ... \\
... & ... & ... & | & ... & ...
\end{pmatrix} \f]

Теорема

В направляющей матрице \f$(v_{ij})\f$ все \f$v_ij=1\f$, а при \f$j>i\f$ все \f$v_ij=0\f$.
Следствие
ДР-последовательность, принадлежащая любому моноциклическому оператору, есть одномерная \f$ЛП_0\f$-последовательность.

2)Построение \f$ЛП_t\f$-последовательностей
Теорема

  1)Пусть \f$L_1\f$,…,\f$L_s\f$ – различные моноциклические операторы, порядки которых равны \f$p_1\f$,…,\f$p_s\f$.
Обозначим \f${p^{(k)}(i)}\f$ какую-нибудь ДР-последовательность, принадлежащую оператору \f$L_k\f$. Последовательность точек \f$P_1\f$,…,\f$P_i,… \f$с координатами \f$P_i=(p^{(1)}(i),…,p^{(n)}(i))\f$ есть \f$ЛП_t\f$-последовательность со значением 
\f[  t=\sum_{k=0}^n\ (p_k-1) \f] (~)
 2)Если все условия этой теоремы выполняются, тогда последовательность точек \f$Q_1\f$,…,\f$Q_i\f$,… с координатами \f$P_i=(p(i),p^{(1)}(i),…,p^{(n)}(i))\f$ есть \f$ЛП_t\f$-последовательность в \f$K^{s+1}\f$ со значением \f$t\f$,определенным суммой теоремы.

Доказательство(схема):

Т.к. \f${p(i)}\f$ представляет собой ДР-последовательность с единичной направляющей матрицей \f$ (v^{(0)}_{ij}=\delta_{ij})\f$, то мы придем к матрице, аналогичной той, что мы получаем в 1 пункте доказательства теоремы.
\f[
\begin{pmatrix}
1 & 0 & ... & 0 & v^{(1)}_{11} & v^{(1)}_{12} & ... & v^{(n)}_{1\mu_n} \\
0 & 1 & ... & 0 & v^{(1)}_{21} & v^{(1)}_{22} & ... & v^{(n)}_{2\mu_n} \\
... & ... & ... & ... & ... & ... & ... & ...\\
0 & 0 & ... & 1 & v^{(1)}_{\mu_0 1} & v^{(1)}_{\mu_0 2} & ... & v^{(n)}_{\mu_0 \mu_n } \\        
\hline \\
0 & 0 & ... & 0 & v^{(1)}_{\mu_0+1,1} & v^{(1)}_{\mu_0+1,2} & ... & v^{(n)}_{\mu_0+1,\mu_n } \\
... & ... & ... & ... & ... & ... & ... & ...\\
0 & 0 & ... & 0 & v^{(1)}_{\gamma 1} & v^{(1)}_{\gamma 2} & ... & v^{(n)}_{\gamma \mu_n }
\end{pmatrix} \f]
Далее повторяя аналогичные рассуждения с док-вом первой части теоремы мы получаем, что ранг нашей матрицы будет равен: 
\f[\mu_0 + p_1\rho_1 +...+p_s\rho_s+\mu_1'+...+\mu_s'=\nu-t \f]

  О точности формулы \f$  t=\sum_{k=0}^n\ (p_k-1) \f$ для \f$t\f$

Теорема(‘)

Предположим, что все условия пункта 1) предыдущей теоремы выполнены. Обозначим \f$\delta_n = \det |a_{k,g} |_1^n\f$. Если мы можем выбрать \f$a_{k,g}\f$ такие, что любой из периодов \f$w_k=2^p_k -1 (1 \le k \le s)\f$, был взаимно простым с \f$\delta_n\f$ , то значение \f$t\f$ , определяемое нашей формулой будет точным для последовательности \f${P_i}\f$ в \f$K^s\f$.
Теперь поговорим о наименьшим значении \f$t\f$ для \f$  t=\sum_{k=0}^n\ (p_k-1) \f$.
Затронем ключевой вопрос для тмс-сетей. А как собственно нам выбирать точки? То есть мы их распределяем по гиперкубу, далее получаем последовательность точек и хотим понять, как же нам выбрать наилучшие точки. 
На самом дело обстоит следующим образом, чем меньше наше \f$ t \f$  тем лучше будут распределены точки \f$ЛП_t\f$-последовательности. По этой причине стоит рассмотреть точки, получающиеся при использовании моноциклических операторов возможно низких порядков.
Введем обозначение \f$n_s\f$-количество моноциклических операторов, порядки которых \f$m \le s\f$.
\f[ n_s =\sum_{p=0}^s\ p^{-1}\phi(2^p-1) \f] 
Если \f$n_s \le n \le n_{s+1}\f$, то наименьшее \f$t{n+1}\f$, которые мы сможем получить из формулы (~) равно:
\f[ t_{s+1} =\sum_{p=1}^s\ (p-1)p^{-1}\phi(2^p-1)+(n-n_s)s \f] 
  или   
\f[ t_{s+1} =\sum_{p=1}^s\ \phi(2^p-1)+(n-n_s)(s+1)-n \f] 

Приведем некоторые значения для \f$t_{n+1}\f$
\f[
\begin{array}{|l|c|r|l|c|r|l|c|r|l|c|r|}
\hline \\
n & 1 &  2 &  3 &  4 &  5 &  6 & 7 & 8 & 9 & 10 & 11 & 12\\
\hline \\
t_{n+1} & 0 & 1 & 3 & 5 & 8 & 11 & 15 & 19 & 23 & 27 & 31 & 35\\
\hline
\end{array}
\f]

Теорема

Для наименьшего значения  \f$t=t_{s+1}\f$, в формуле \f$  t=\sum_{k=0}^n\ (p_k-1) \f$ при \f$n->?\f$ справедлива следующая оценка: \f$t_{s+1} \le m[\log_{2}s+ \log_{2}log_{2}n+\log_{2}log_{2}log_{2}s +O(1)]\f$.
В тоже время \f$t_{s+1} \ge С_1 \frac{log_{2}s}{log_{2}log_{2}s} \f$,  где \f$С_1>0\f$.

   Дополнение про последовательности

Последовательность ван дер Корпута имеет вид: \f$p(i)=e_12^{-1}+e_22^{-2}+…+e_m2^{-m}\f$. Она представляет собой простейшую ДР-последовательность, где направляющие числа \f$V_s=2^{-s}\f$.
Также вводится более грубая оценка для параметра отклонения, которая оказывается лучше упомянутой ранее для \f$ЛП_0\f$-последовательности для некоторых значений \f$m\f$.
\f$t\f$-кол-во единиц в двоичной записи числа
\f[ D(x_0,...,x_{m-1})?(1/3)log_{2}m+O(1) \f]

Свойство 1:
	Любой участок последовательности \f${p(i)}\f$, содержащий \f$2^k\f$ точек \f$(k=1,2,…)\f$, представляет собой \f$П_0\f$-сетку.
Свойство 2:
	Для любого участка \f$i’ \le i \le I’’\f$ последовательности \f${p(i)}\f$ неравномерность равна единице,т.е. \f$\phi_\infty( p(I’),…,p(I’’))=1\f$

Следует отметить, что такими свойствами обладает не каждая \f$ЛП_0\f$-последовательность двоично рационального типа.

Отметим еще одну особую последовательность \f${q(i)}\f$, которая называется ДР-последовательностью, если направляющая матрица \f$(v_{sj})\f$ такова, что \f$(v_{sj})=c_{sj}(mod2)\f$.

Отдельного внимания заслуживает тот факт, что рассмотренные нами последовательности являются симметричными в следующем смысле \f$p(k)=q(i)\f$;\f$ p(i)=q(k)\f$.

Еще немало важным фактом является то, что последовательность с декартовыми координатами \f$(p(i), q(i))\f$ представляет собой двумерную \f$ЛП_0\f$- последовательность. Что очевидным образом наводит на мысль, что с ростом размерности пространства, \f$ЛП_t\f$- последовательность будет приобретать все большее количество координат, которые содержат используемые последовательности. В двумерном случает это координаты из \f${p(i)}\f$  и \f${q(i)}\f$.


        Многомерные задачи

Все необходимое для многомерных задач было задано в самом начале, потому пробежимся быстро по свойствам и недостающим понятиям.

1)Отклонение

Отклонением сетки \f$P_0,P_1,…,P_{m-1}\f$ называется число \f$ D(P_0,P_1,…,P_{m-1})=\sup | S_m(\pi_p)-mV_p|\f$.
Лучшими считаются оценки для n-мерной сетки \f$ D=O(ln^{s-1}m)\f$  
Оценка n-мерной последовательности \f$ D=O(ln^sm)\f$

2)Неравномерность

Неравномерностью сетки \f$P_0,P_1,…,P_{m-1}\f$ называется наибольшая верхняя грань 
\f$ \phi_\infty(P_0,P_1,…,P_{m-1})= \max_{\beta} \sup_{k}| S_m(V_k^+) –S_m(V_k^-) |  \f$
                                  
Оценка \f$ \phi_\infty\f$ через \f$D\f$
\f[ \phi_\infty(P_0,…,P_{m-1})\le 4^sD(P_0,...,P_{m-1}) \f]
          
3)Разброс

Определяется аналогично с одномерным случаем \f[ d = \sup_{P} \min_{0\le i \le m-1}\sigma(P,p_i) \f]


  Дополнительная информация к построению \f$ЛП_t\f$-последовательности (переход от одномерного к многомерному)

Естественно пытаться строить \f$ЛП_t\f$-последовательности так, чтобы каждая её координата представляла одномерную \f$ЛП_0\f$-последовательность. Причем просто их построить не так уж и трудно. Куда труднее их построить так, чтобы они были независимыми. Для этой цели используются линейные разностные операторы. О которых мы упоминали ранее.

\f$П_0\f$-сетки. По аналогии с одномерным случаем назовем \f$П_0\f$-сеткой сетку, состоящую из \f$2^\gamma\f$ точек куба \f$К^s\f$, если каждому двоичному \f$\pi_k\f$ с объемом \f$1/m\f$ принадлежит одна точка сетки. В одномерном случает построение \f$П_0\f$-сеток было простой задачей, ибо существует всего \f$N\f$ двоичных отрезков длиной \f$1/m\f$. Однако с увеличением \f$s\f$ количество двоичных параллелепипедов с объемом \f$1/m\f$ быстро возрастает и расположить \f$m\f$ точек так, чтобы они образовывали \f$П_0\f$-сетку довольно проблематично.

Двухмерные сетки образуют точки с координатами \f$(i/m,p(i))\f$ при \f$0 \le i \le m-1\f$. Трехмерные – с координатами \f$(i/m,p(i),q(i))\f$ при \f$0 \le i \le m-1\f$ \f$m=2^\gamma\f$ , \f$p(i)\f$ и \f$q(i)\f$ –последовательности, которые мы определяли ранее. Справедливость сказанного подтверждает теорема о построении \f$П_t\f$-сеток в \f$K^{s+1}\f$ c помощью \f$ЛП_t\f$-последовательностей из \f$K^n\f$.

Однако переход к четырехмерному случаю оказался неожиданно трудным и завершилось это доказательством утверждения, что в \f$K^4\f$ невозможно построить \f$П_0\f$-сетку, содержащую \f$s?4\f$ точек. По этой причине пришлось ослабить требования к распределению точек сетки по двоичным параллелепипедам, и ввести более общее определение.

Сетка, состоящая из \f$m=2^\gamma\f$ точек куба \f$K^s\f$, называется \f$П_t\f$-сеткой, если каждому двоичному параллелепипеду с объемом \f$2^t/m\f$ принадлежит \f$2^t\f$ точек сетки.

Добавим еще немного информации по поводу точности распределения точек по кубу. \f$П_\tau\f$-сетки, содержащие сколько угодно большое количество  \f$m=2^\gamma\f$ точек, существует в пространствах любой размерности \f$n\f$, но значение \f$t \f$приходится увеличивать с ростом \f$s\f$. Обозначим через \f$t(s)\f$ наименьшее значение \f$t\f$ такое, что в \f$K^s\f$ существуют \f$П_\tau\f$-сетки, содержащие сколь угодно большие количества точек \f$m=2^\gamma\f$. Точные значения известны только для низших размерностей:
\f$t(1)= t(2)= t(3)=0, t(4)=1\f$

Для любых \f$П_\tau\f$-сеток в \f$K^s\f$ справедливы оценки \f$ \phi_\infty=O(1), D=O(ln^{s-1}m)\f$.

Таким образом при построении гиперкубов все большей размерности мы наблюдаем явление “антипроекции”. Для одномерной задачи мы рассматриваем двоичные отрезки. Переходя далее к двумерному случаю (квадрат), мы проецируем квадрат на какую-либо ось и получаем отрезок. Далее переходим к третьему измерению. Тут у нас уже в качестве проекции куба на какую-либо ось будет выступать квадрат, в четырех мерном случае это уже будет куб и тд. Мы видим, что при переходе к гиперкубу все большей размерности, то, что у нас выступало в роли двоичного отрезка “набирает” размерность. В итоге мы рассматриваем \f$n\f$-мерные параллелепипеды. Таким образом мы идем как бы в обратном проекции направлении. Очевидно, что в одномерном случае у нас имелось \f$m\f$ двоичных отрезков длины \f$1/m\f$. С ростом \f$s\f$ кол-во двоичных параллелепипедов растет и расположить \f$m\f$ точек так, чтобы они образовывали \f$П_0\f$-сетки становится тяжелой задачей. Именно по этому, как и говорилось ранее, пришлось вводить более общее понятие - \f$П_\tau\f$-сеток, где двоичному параллелепипеду принадлежит уже не \f$1\f$,а \f$2^t\f$ точек.


 Еще несколько свойств \f$П_t\f$-сеток

1)Проекция точек \f$П_t\f$-сетки на какую-нибудь \f$s\f$-мерную грань \f$K_\beta\f$ куба \f$K^s\f$, где \f$1 \le s \le n-1\f$, образуют \f$s\f$-мерную \f$П_t\f$-сетку. Для этой \f$s\f$-мерной сетки значение \f$\tau\f$ не превосходит этого значения для исходной сетки и может оказаться строго меньше.

2)В \f$K^s\f$ любой \f$П_\tau\f$-сетки справедлива оценка \f$\phi_\infty \le 2^{s-1+t}\f$.

3)При \f$n=1,2,3\f$ и \f$N \ge 2^{s-1}\f$ для любой \f$П_0\f$-сетки в \f$K^n\f$ неравенства предыдущего свойства обращается в равенство, то есть \f$\phi_\infty=2^{s-1+t}\f$.

Из первого свойства вытекает, что проекции точек \f$ЛП_t\f$-последовательности на любую \f$s\f$-мерную грань \f$K_\beta\f$ образуют \f$s\f$-мерную \f$ЛП_t\f$-последовательность (с тем же или даже меньшим параметром \f$t\tau\f$).

       
       Часть 2. Исследования Фора

Фор говорил о так называемых \f$r\f$-ичных \f$ЛП_0\f$-последователностях. Отличие их от обычных \f$ЛП_0\f$-последователностей в том, что мы рассматриваем \f$r \ge 2\f$ и получаем вместо двоичных \f$r\f$-ичные отрезки, получаемы путем деления \f$[0,1]\f$ на \f$r^a\f$ равных частей. 

Последовательность что строил Фор представляют собой обобщение двоичной \f$ЛП_0\f$-последователности в \f$К^2\f$. Для построения используется бесконечная единичная матрица,а также матрица Паскаля \f$С\f$. В качестве направляющих матриц используются любые матрицы из группы \f$ E, C(modr), C^2(modr),...C^{r-1}(modr) \f$. 

Как результат. Мы получаем новые возможности для построения сеток. Для начальных участков любой \f$r\f$-ичной \f$ЛП_0\f$-последователности справедлива оценка \f$D=O(ln^sm)\f$,а при \f$m=r^a\f$ мы можем получить более сильную оценку \f$D=O(ln^{s-1}m)\f$.


       Часть 3. (t,m,s)-сети и их свойства 
(t,m,s)-сети

Для данного измерения \f$s \ge 1\f$ и целого \f$b \ge 2\f$ и неотрицательного целого числа \f$k\f$, \f$b\f$-адический \f$s\f$-мерный элементарный интервал порядка \f$k\f$ имеет вид 
\f[ J = \prod_{i=1}^{s}\left( \frac{A_i}{b^{d_i}},\frac{A_i+1}{b^{d_i}} \right)\f] 


 Где \f$d_1\f$,…,\f$d_s\f$ из \f$ N_0 \f$ и их сумма равна \f$ k \f$ и \f$ 0 \le A_i<b^{d_i} \f$ для \f$ 1 \le i \le s\f$.

Для измерения \f$s \ge 1\f$ и целого \f$b \ge 2\f$,  положительное целое \f$ m\f$ и целое \f$t \f$ \f$(0 \le t \le m)\f$, множество точек \f$P\f$ из \f$b^m\f$  из отрезка \f$[0,1)^s\f$ называется \f$(t,m,s)\f$- сетью по основанию \f$b\f$, если множество точек \f$ P\f$ удовлетворяет всем \f$b\f$-адическим \f$s\f$-мерным элементарным интервалам порядка \f$m-t\f$. 

\f$(t,m,s)\f$-сетью по основанию \f$b\f$ с \f$t \ge 1\f$ называется строгой \f$(t, m, s) \f$-сетью по основанию \f$b \f$, если она не является \f$(t-1, m, s) \f$-сетью по основанию \f$b \f$. Кроме того \f$ (0, m, s)\f$ -сеть по основанию \f$b \f$ называется строгой по определению.


Свойства:

1) То, что мн-во \f$P \f$ по основанию \f$b \f$  есть \f$(t,m,s)\f$-сеть означает, что для любого интервала \f[ J = \prod_{i=1}^{s}\left( \frac{A_i}{b^{d_i}},\frac{A_i+1}{b^{d_i}} \right)\f] с суммой \f$ d_i \f$ равной \f$ m-t\f$ , с объемом \f$ b^{-m+t}\f$ содержит ровно \f$b^t\f$ точек из \f$P\f$.

2) Так как для каждого \f$ k \ge 1\f$ каждый \f$b\f$-адический  \f$s\f$-мерный элементарный интервал порядка \f$ k-1\f$ (объемом \f$b^{-m+t}\f$) является объединением \f$ b\f$ непересекающихся \f$b\f$-адических \f$s\f$-мерных элементарных интервалов порядка \f$k \f$, каждая \f$(t,m,s)\f$-сеть на базе \f$b\f$ с \f$t \le m-1\f$ также является \f$(t+1, m, s)\f$ -сетью по основанию \f$b\f$.

3) Каждая точка задает  \f$b^m\f$ точек в \f$[0, 1)^s\f$  и является \f$(t, m, s)\f$ -сетью по основанию \f$b\f$.Состояние то в том, что интервал \f$J = [0, 1)^s\f$  содержит \f$b^m\f$ точек  множества,  которое является тривиальным.

4) Не имеет смысла, определять понятие \f$(m, m, s)\f$ -сетей по основанию \f$b\f$ для отрицательного \f$t\f$, так как множество  \f$b^m\f$  точек не может быть верным по отношению к интервалу объем меньше, чем \f$b^{-m}\f$.

5) Мы называем \f$t\f$ параметром качества \f$(t, m, s) \f$-сети.


Теорема (о параметре качества)

Для \f$ 1 \le j \le r \f$ пусть \f$P_j (t_j , m_j , s)\f$-сеть по основанию  \f$b\f$ с \f$m_1,...,m_r\f$ таких, что \f$b^{m_1} +...+ b^{m_r} = b^m \f$ для некоторого целого \f$m\f$. Тогда произведение \f$P := P_1 \cup ... \cup P_r\f$ это \f$(t, m, s)\f$-сеть по основанию  \f$b\f$ с  \f$ t=m - \min_{1 \le j \le r} (m_j – t_j )\f$

Утверждение

\f$A (0, m, s)\f$-сеть по основанию  \f$2\f$ не может существовать, если \f$ m \ge 2 \f$ и \f$ s \ge 4 \f$. 

Но вопросом особой важности является вопрос о существовании \f$(0, m, 3)\f$-сети по основанию \f$2\f$ для любого \f$ m \ge 2 \f$. Потому что именно этим вопросом занимался Соболь и в некоторой степени Фор. 

Но мы вернемся к этому позже. Сейчас необходимо прежде всего ввести определение последовательностей по аналогии с теми, что вводил Соболь. Для \f$П_\tau\f$-сеток было введено определение \f$ЛП_\tau\f$-последовательности. Введем аналогичным образом на основании \f$(t,m,s)\f$-сетей определение \f$(t,s)\f$- последовательности. В дальнейшим мы убедимся, что \f$ЛП_\tau\f$-последовательность, это особый случай \f$(t,s)\f$- последовательности.То же самое касается и тех последовательностей, что вводил Фор.

Для данного измерения  \f$ s\ge 1 \f$, целого основания \f$ b\ge 2 \f$ и неотрицательного целого \f$t \f$, a последовательность \f$(x_0, x_1,...)\f$ точек из \f$[0, 1)^s\f$ называется  \f$(t,s)\f$- последовательностью по основанию \f$b\f$, если для всех целых  \f$m>t\f$ и \f$k \ge 0\f$, множество точек состоит из точек \f$x_{kb}^m ,..., x_{kb}^m+b^m - 1\f$ формирует \f$(t, m, s)\f$-сеть по основанию \f$b\f$.

\f$A (t,s)\f$-последовательность  по основанию  \f$b\f$ с \f$t \ge 1\f$ называется точной \f$(t,s)\f$- последовательностью по основанию \f$b\f$, если не существует \f$A (t-1, s)\f$-последовательности по основанию \f$b\f$. \f$(0, s)\f$-последовательность точная по определению.

Для данного измерения  \f$s \ge 1\f$, целого основания \f$b \ge 2\f$, функция  \f$T : N_0 > N_0\f$ с \f$T(m) \le m\f$ для всех \f$m \in N_0\f$,  последовательность \f$(x_0, x_1,...)\f$ точек из \f$[0, 1)^s\f$ называется  \f$(T, s)\f$-последовательностью по основанию \f$b\f$, если для всех целым \f$m \ge 0\f$ и \f$k \ge 0\f$, множество точек состоит из \f$t\f$.

\f$(T, s)\f$-последовательность  по основанию \f$b\f$ называется точной  \f$(T, s)\f$-последовательность по основанию \f$b\f$, если для всех функций  \f$U : N_0 \to N_0\f$ с \f$U(m) \le m\f$ для всех \f$m \in N_0\f$ и с \f$U(m)<T(m)\f$, что по крайней мере одно \f$m \in N_0\f$, не будет \f$(U, s)\f$-последовательностью по основанию \f$b\f$.

Как мы можем видеть из приведенных определений, определение данное Соболем  аналогично данному Нидерайтером с той поправкой, что основание \f$b=2\f$.

 
     Сравнительный анализ

В заключении нашей работы рассмотрим проведем сравнительный анализ всех рассмотренных последовательностей, поскольку возникает вопрос: Что же лучше? 

Касаемо последовательностей Соболя можно сказать, что они обладают дополнительными свойствами равномерности, которые хороши для небольших порядков. 
Что же о последовательностях Фора – они обладают хорошей ассимптотикой в формулах для отклонений. Этот вопрос далее еще развивал Холтон, но опустим это и перейдем непосредственно к Нидерайтеру.

Дополнительные свойства равномерности последовательности по Соболю:
1)Равномерность должна быть ассимптотически оптимальной
2)Равномерность расположения точек должна наблюдаться не только при \f$m\f$ стремящимся в бесконечность, но уже и при малых \f$m\f$.
3)Алгоритм для получения точек с данными условиями должен быть максимально простым.

Нидерайтер дал более общее определение для всех последовательностей, что мы рассматрели. И о последовательностях Соболя и Фора в рамках такого определения мы можем говорить, как о частных случаях. 
Куда более важно, так это свойства последовательностей Нидерайтера. Для них в сравнении с \f$ЛП_?\f$-последовательностями ослабевают условия равномерности и доступна более сильная оценка отклонений \f$m\f$ \f[D_m^*(P) \le B(s,b)b^t(logm)^{s-1} + O((logm)^{s-2})\f]
 
*/



#include <iostream>
#include <cmath>
#include <fstream>
#include <vector>
#include <algorithm>
#include <iomanip>
using namespace std;

/*
maxdim - макс размерность пространства
maxfig - максимальное количество чисел с основанием Q , которое мы можем обработать
nbits - число бит в слове (сейчас 31, для поддержания платформонезависимости)
c - хранит числа Нидеррайтера (I,J,R)
count - индекс текущего элемента в C
d - значения D(I,J)
nextq - номер следующего элемента
qpow - хранит степени Q
dimen - размерность генерируемой последовательности
nfigs - количество  чисел по основанию Q, которые мы используем по факту
recip - переменная, хранящая 1 / (Q ^ NFIGS)

maxq - максимальное значение Q
maxdeg - наибольшая степень полинома (многочлена)
deg - текущая степень многочлена
p, q - характеристики поля
add - результат сложения многочленов
mul - результат умножения
sub - результат деления
*/

// COMM
/*!
\param maxdim - макс размерность пространства
*/
const int maxdim = 20;
/*!
\param maxfig - максимальное количество чисел с основанием Q , которое мы можем обработать
*/
const int maxfig = 20;
/*!
\param nbits - число бит в слове
*/
const int nbits = 31;

int c[maxdim][maxfig][maxfig/*!*/]; 
/*!
\param c - хранит числа Нидеррайтера (I,J,R)
*/
int count[maxfig/*!*/]; 
/*!
\param count - индекс текущего элемента в C
*/
int d[maxdim][maxfig];
/*!
\param d - значения D(I,J)
*/
int nextq[maxdim];
/*!
\param nextq - номер следующего элемента
*/
int qpow[maxfig];
/*!
\param qpow - хранит степени Q
*/
int dimen;
/*!
\param dimen - размерность генерируемой последовательности
*/
int nfigs;
/*!
\param nfigs - количество  чисел по основанию Q
*/
double recip;
/*!
\param recip - переменная, хранящая 1 / (Q ^ NFIGS)
*/

// COMM2
int cj[maxdim][nbits/*!*/];
/*!
\param cj - хранит числа Нидеррайтера (I,J,R)
*/
int count2;
/*!
\param count2 - индекс текущего элемента в C
*/
int dimen2;
/*!
\param dimen2 - значения D(I,J)
*/
int nextq2[maxdim];
/*!
\param nextq2 - номер следующего элемента
*/

// FIELD
const int maxq = 50;
/*!
\param maxq - максимальное значение Q
*/
const int maxdeg = 50;
/*!
\param maxdeg - наибольшая степень полинома (многочлена)
*/
const int deg = 0;
/*!
\param deg - текущая степень многочлена
*/
int p;
/*!
\param p - характеристика поля
*/
int q;
/*!
\param q - характеристика поля
*/
int add[maxq/*!*/][maxq/*!*/];
/*!
\param add - результат сложения многочленов
*/
int mul[maxq/*!*/][maxq/*!*/];
/*!
\param mul - результат умножения
*/
int sub[maxq/*!*/][maxq/*!*/];
/*!
\param sub - результат деления
*/


vector < vector <double> > vResult;
/*!
\param vResult - хранит найденные точки
*/
vector <double> vector_;
/*!
\param vResult - хранится текущая точка
*/
int ResultCounter = 0;

/*!
\brief Структура для хранения номера точки и значения функции в ней
\param point - номер точки
\param value - значение функции
*/
struct point
{
    int point;
    double value;
};

// эта подпрограмма инициализирует таблицы сложений, умножений, вычитаний
/*!
\brief Подпрограмма инициализирует таблицы сложений, умножений, вычитаний для конечных полей порядка qin
\param int qin - порядок конечного поля
\return таблицы
*/
void SETFLD(int qin)
{
    cout << "SETFLD" << endl;
    int i,j;
    if (qin <= 1 || qin > maxq) cout << "SETFLD: Bad value of Q";
    q = qin;
    p = q;
    if (p == 0) cout << "SETFLD: There is no field of order" << q;

    for(i = 0; i < q; ++i)
        for(j = 0; j < q; ++j)
        {
            add[i][j] = (i + j) % p;
            mul[i][j] = (i * j) % p;
        }

    for (i = 0; i < q; ++i)
        for (j = 0; j < q; ++j) sub[add[i][j]][i] = j;
}

//Программа используется для умножения полиномов
/*!
\brief Подпрограмма для умножения полиномов
\param int *pa - первый полином
\param int *pb - второй полином
\param int *pc - результат
*/
void PLYMUL(int *pa, int *pb, int *pc)
{
    int i,j,dega,degb,degc,term;
    int pt[maxdeg+2];
    dega = pa[deg];
    degb = pb[deg];
    if (dega == -1 || degb == -1) degc = -1;
    else degc = dega + degb;
    if (degc > maxdeg)
        cout << "PLYMUL: Degree of product exceeds MAXDEG" << endl;
    for (i = 0; i <= degc; ++i)
    {
        term = 0;
        for(j = max(0,i-dega); j <= min(degb,i); ++j)
            term = add[term][mul[pa[i-j+1]][pb[j+1]]];
        pt[i+1] = term;
    }
    pc[deg] = degc;
    for(i = 1; i <= degc + 1; ++i) pc[i] = pt[i];
    for(i = degc + 2; i < maxdeg + 2; ++i) pc[i] = 0;
}

/*
  C помощью этой программы вычисляем значения констант V(J,R)

  px соответствующего неприводимого полинома для  текущего измерения
  На входе в подпрограмму, степень B  определяет параметр J, как deg(B) = Е*(J-1), где Е - степень px.
  MAXV дает размерность массива V.

  результат выполнения - B умноженный на px, его степень на данный момент Е*J.
  V содержит требуемыые значения.
  подпрограмма PLYMUL используется для умножения полиномов
*/
/*!
\brief Подпрограмма вычисляет значения констант V(J,R) px соответствующего неприводимого полинома для  текущего измерения 
\param int *px - полином
\param int *b - определение пармаметра J
\param int *v - массив
\param int maxv - размерность массива V
*/
void CALCV(int *px,int *b,int *v,int maxv)
{
    int h[maxdeg+2];
    int bigm = 0, m = 0, kj, term;
    int arbit = 1,nonzer = 1;

    for(int i = 0; i < b[deg]+2; ++i)
        h[i] = b[i];
    bigm = h[deg];
    PLYMUL(px,b,b);

    m = b[deg];

    kj = bigm;
    for(int r = 0; r < kj; ++r)
        v[r] = 0;
    v[kj] = 1;

    if(kj < bigm)
    {
        // weak branch
        term = sub[0][h[kj+1]];
        for(int r = kj - 1; r < bigm - 1; ++r)
        {
            v[r] = arbit;
            term = sub[term][ mul[h[r+1]][v[r]] ];
        }
        v[bigm] = add[nonzer][term];
        for(int r = bigm + 1; r < m - 1; ++r)
            v[r] = arbit;
    }
    else
        for(int r = kj + 1; r <= m - 1; ++r)
            v[r] = arbit;
    for(int r = 0; r <= maxv - m; ++r)
    {
        term = 0;
        for(int i = 0; i <= m - 1; ++i)
            term = sub[term][ mul[b[i+1]][v[r+i]] ];
        v[r+m] = term;
    }
}

/*
C помощью этой программы вычисляем значения константы  C(I,J,R).
для каждого значения I, мы сначала рассчитываем все соответствующие значения  C : они хранятся в массиве CI.
Все  значения C  0 или 1. Далее мы помещаем значения в массив  СJ, таким образом,  CJ(I,R) имеет значения С
для указанных значений I и R, и для каждого J от 1 до NBITS
И когда значения CJ(I,R) расчитаны, мы возвращаемсяк этому массиву в вызываемой программе
*/
/*!
\brief Подпрограмма вычисляет значения констант  C(I,J,R)для каждого значения I
\param int maxe - максимальное значение Е
\param int maxv - размерность массива V
\param int px [] - массив
\param int b [] - массив коэфициентов b
\param int v [] - массив
\param int ci [][] - массив, хранящий числа Нидеррайдера
\param int i - индекс
\param int j - индекс
\param int r - индекс
\param int irred [][] - массив коэфициентов неприводимых многочленов над полем \f$Z_2\f$
*/
void CALCC2()
{
    int maxe = 5, maxv = nbits + maxe;
    int px[maxdeg+2], b[maxdeg+2];
    int v[maxv+1], ci[nbits][nbits];
    int e,i,j,r,u,term;
    int irred[maxdim][maxe+2];
    {
        irred[0][0] = 1;
        irred[0][1] = 0;
        irred[0][2] = 1;

        irred[1][0] = 1;
        irred[1][1] = 1;
        irred[1][2] = 1;

        irred[2][0] = 2;
        irred[2][1] = 1;
        irred[2][2] = 1;
        irred[2][3] = 1;

        irred[3][0] = 3;
        irred[3][1] = 1;
        irred[3][2] = 1;
        irred[3][3] = 0;
        irred[3][4] = 1;

        irred[4][0] = 3;
        irred[4][1] = 1;
        irred[4][2] = 0;
        irred[4][3] = 1;
        irred[4][4] = 1;

        irred[5][0] = 4;
        irred[5][1] = 1;
        irred[5][2] = 1;
        irred[5][3] = 0;
        irred[5][4] = 0;
        irred[5][5] = 1;

        irred[6][0] = 4;
        irred[6][1] = 1;
        irred[6][2] = 0;
        irred[6][3] = 0;
        irred[6][4] = 1;
        irred[6][5] = 1;

        irred[7][0] = 4;
        irred[7][1] = 1;
        irred[7][2] = 1;
        irred[7][3] = 1;
        irred[7][4] = 1;
        irred[7][5] = 1;

        irred[8][0] = 5;
        irred[8][1] = 1;
        irred[8][2] = 0;
        irred[8][3] = 1;
        irred[8][4] = 0;
        irred[8][5] = 0;
        irred[8][6] = 1;

        irred[9][0] = 5;
        irred[9][1] = 1;
        irred[9][2] = 0;
        irred[9][3] = 0;
        irred[9][4] = 1;
        irred[9][5] = 0;
        irred[9][6] = 1;

        irred[10][0] = 5;
        irred[10][1] = 1;
        irred[10][2] = 1;
        irred[10][3] = 1;
        irred[10][4] = 1;
        irred[10][5] = 0;
        irred[10][6] = 1;

        irred[11][0] = 5;
        irred[11][1] = 1;
        irred[11][2] = 1;
        irred[11][3] = 1;
        irred[11][4] = 0;
        irred[11][5] = 1;
        irred[11][6] = 1;

        irred[12][0] = 5;
        irred[12][1] = 1;
        irred[12][2] = 1;
        irred[12][3] = 0;
        irred[12][4] = 1;
        irred[12][5] = 1;
        irred[12][6] = 1;

        irred[13][0] = 5;
        irred[13][1] = 1;
        irred[13][2] = 0;
        irred[13][3] = 1;
        irred[13][4] = 1;
        irred[13][5] = 1;
        irred[13][6] = 1;

        irred[14][0] = 6;
        irred[14][1] = 1;
        irred[14][2] = 1;
        irred[14][3] = 0;
        irred[14][4] = 0;
        irred[14][5] = 0;
        irred[14][6] = 0;
        irred[14][7] = 1;

        irred[15][0] = 6;
        irred[15][1] = 1;
        irred[15][2] = 0;
        irred[15][3] = 0;
        irred[15][4] = 1;
        irred[15][5] = 0;
        irred[15][6] = 0;
        irred[15][7] = 1;

        irred[16][0] = 6;
        irred[16][1] = 1;
        irred[16][2] = 1;
        irred[16][3] = 1;
        irred[16][4] = 0;
        irred[16][5] = 1;
        irred[16][6] = 0;
        irred[16][7] = 1;

        irred[17][0] = 6;
        irred[17][1] = 1;
        irred[17][2] = 1;
        irred[17][3] = 0;
        irred[17][4] = 1;
        irred[17][5] = 1;
        irred[17][6] = 0;
        irred[17][7] = 1;

        irred[18][0] = 6;
        irred[18][1] = 1;
        irred[18][2] = 0;
        irred[18][3] = 0;
        irred[18][4] = 0;
        irred[18][5] = 0;
        irred[18][6] = 1;
        irred[18][7] = 1;

        irred[19][0] = 6;
        irred[19][1] = 1;
        irred[19][2] = 1;
        irred[19][3] = 1;
        irred[19][4] = 0;
        irred[19][5] = 0;
        irred[19][6] = 1;
        irred[19][7] = 1;
    }
    SETFLD(2);

    for(i = 0; i < dimen; ++i)
    {
        e = irred[i][deg];
        b[deg] = 0;
        b[1] = 1;
        u = 0;
        for(j = 0; j < e + 2; ++j)
            px[j] = irred[i][j];

        for(j = 0; j <= nbits - 1; ++j)
        {
            if (u == 0) CALCV(px, b, v, maxv);
            for(r = 0; r <= nbits - 1; ++r)
                ci[j][r] = v[r+u];
            ++u;
            if(u == e) u = 0;
        }
        for(r = 0; r <= nbits - 1; ++r)
        {
            term = 0;
            for(j = 1; j <= nbits; ++j)
                term = (term << 1) + ci[j-1][r];
            cj[i][r] = term;
        }
    }
}

/*
Эта подпрограмма вычисляет значения нидеррейтера C(I,J,R) , вызывая CALCC2 и выполняет другие необходимые инициализации перед вызовом GOLO2
dim - измерение последовательностей, которые должны быть созданы.
skip - количество значений, которые должны быть отброшены в начале последовательности
*/
/*!
\brief Подпрограмма вычисляет значения нидеррейтера C(I,J,R)
\param int dim - измерение последовательностей, которые должны быть созданы
\param int skip - количество значений, которые должны быть отброшены в начале последовательности
*/
void INLO2(int dim, int skip)
{
    int r, gray;
    dimen2 = dim;
    if(dimen2 <= 0 || dimen2 > maxdim)
    {
        cout<<"INLO2 : Bad dimension";
        return;
    }

    CALCC2();
    gray = skip xor skip >> 1;
    for(int i = 1; i <= dimen2; ++i) nextq2[i-1] = 0;
    r = 0;
    while(gray != 0)
    {
        if(gray % 2 != 0)
            for(int i = 1; i <= dimen2; ++i)
                nextq2[i-1] = nextq2[i-1] xor cj[i-1][r];
        gray >>= 1; //делим на 2
        r++;
    }
    count2 = skip;
}

/*
Эта функция создает новый квази-случайный вектор на каждый вызов программы
bounds - границы области, в которой генерируются точки.
*/
/*!
\brief Функция создает новый квази-случайный вектор на каждый вызов программы
\param double *quasi - квази-случайный вектор
*/
void GOLO2(double *quasi, vector< vector<double> >& bounds)
{
    int r;
    recip = pow(2, -nbits);
    for(int i = 0; i < dimen2; ++i)
    {
        quasi[i] = nextq2[i] * recip;
        vResult[ResultCounter][i] = bounds[i][0] + (bounds[i][1]-bounds[i][0])*quasi[i];
    }
    ++ResultCounter;

    r = 0;
    int i = count2;
    while(i % 2 != 0)
    {
        r++;
        i >>= 1;
    }
    if(r >= nbits)
    {
        cout<<"GOLO2 : Too many calls";
        return;
    }
    for(int I = 0; I < dimen2; ++I)
        nextq2[I] = nextq2[I] xor cj [I][r];
    ++count2;
}

//Фукнция, которую мы минимизируем
/*!
\brief Фукнция, которую мы минимизируем
\param p - ссылка на вектор
\return значение фукции в точке
*/
double func(vector<double>& p)
{
    return p[0]*p[0]+p[1]*p[1];
}

//Функция сравнения точек для сортировки
/*!
\brief Функция сравнения точек для сортировки
\param const void *a - указатель на точки для сравнения
\param const void *b - указатель на точки для сравнения
\return результат сравнения
*/
int cmp(const void *a, const void *b)
{
    struct point *x = (struct point *) a;
    struct point *y = (struct point *) b;
    return 2*((x->value - y->value)>0)-1;
}

/*
C помощью этой программы тестируем на точность численное интегрирование
C помощью малых отклонений двоичных последовательностей Нидеррайтера (1988), как это реализовано в INLO2, GOLO2.
Различные возможные проверки интегралов GENIN2 генерирует только  последовательности с основанием 2.
dime_ - размерность пространвства
sqlen_ - колличество точе
m_ - колличество минимальныйх точек для запуска функций минимизации.
bounds - границы области
*/
/*!
\brief Подпрограмма, которая тестирует на точность численное интегрирование с помощью малых отклонений двоичных последовательностей Нидеррайдера
*/
void GENIN2(int dimen_, int seqlen_, int m_, double (*fun)(vector<double>&), vector< vector<double> >& bounds) // PROGRAM
{
    dimen=dimen_;
    int seqlen=seqlen_;
    int m=m_;

    // выделяем память для точек. количество точек: seqlen; координат на точку: dimen
    vResult.resize(seqlen);
    vector_.resize(seqlen);
    for(int i=  0; i < seqlen; ++i)
        vResult[i].resize(dimen);

    int skip = 0;

    INLO2(dimen, skip);
    cout << "GENIN2 :  Initialization complete" << endl;

    double quasi[maxdim];

    for(int i = 1; i <= seqlen; ++i)
        GOLO2(quasi, bounds);

    cout << "GENIN2:  iteration ends" << endl;


    //int k; //количество точек в сетке
    ofstream fout("out.txt");
    struct point * values = (struct point*) calloc(seqlen,sizeof(struct point));

    for (int i = 0; i < seqlen; ++i)
    {
        for (int j = 0; j < dimen; ++j)
        {
            vector_[j]=vResult[i][j];
            fout<< fixed << setprecision(9)<<vResult[i][j]<<" ";
        }
        fout<<endl;
        values[i].value = fun(vector_); //записываем в вектор значение функции в данной точке
        values[i].point = i; //записываем в вектор номер данной точки
    }
    fout.close();

    qsort(values, seqlen, sizeof(struct point), cmp); // сортируем вектор значений функции и запоминаем какой точке принадлежит каждое значение

    ofstream fout1("out_min.txt"); // файл, в котором хранятся все m точек, где функция минимальна

    for (int p = 0; p < m; ++p)
    {
        for (int t = 0; t < dimen; ++t)
            fout1<< vResult[values[p].point][t]<< " "; // записываем в файл координаты точек, в которых функция принимает минимальное значение
        fout1 <<" "<< values[p].value<< endl;
    }

    fout1.close();
    cout << "Answer in out_min.txt" << endl;
    free (values);
}

/*!
\brief Главная функция
\param m - количество точек, которые мы возвращаем
\param d - размерность пространства
\param s - количество точек
*/
int main()
{
    int m,d,s;
    vector< vector<double> > bounds;
    do
    {
        cout << "Enter dimension: ";
        cin >> d;
        if( d > maxdim ) cout << "Dimension may not exceed " << maxdim << endl;
    }
    while(d > maxdim);

    bounds.resize(d);
    cout << "Enter bound for every dimension: ";
    for(int i=0; i < d; ++i)
    {
        bounds[i].resize(2);
        cout<<"Enter 2 bounds for "<<i+1<<" dimension: ";
        cin>>bounds[i][0]>>bounds[i][1];
    }

    cout << "Choose sequence length from list below: " << endl;
    int pow_;
    pow_ = 1 << 10;
    cout << "2^10 = " << pow_ << endl;
    pow_ = 1 << 15;
    cout << "2^15 = " << pow_ << endl;
    pow_ = 1 << 20;
    cout << "2^20 = " << pow_ << endl;
    do
    {
        cout << "Sequence length: ";
        cin >> s;
        if( s < 0 ) cout << "Length must be strictly positive" << endl;
    }while(s < 0);
    cout << "How many dots you want: ";
    cin >> m;

    double (*f_pointer)(vector<double>&) = &func;

    GENIN2(d, s, m, f_pointer, bounds);

    return 0;
}
